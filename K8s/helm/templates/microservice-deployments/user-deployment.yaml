kind: ConfigMap
apiVersion: v1
metadata:
  name: user-service-code-revision
data:
  server.js: |
    const instana = require('@instana/collector');
    const jwt = require('jsonwebtoken');
    // init tracing
    // MUST be done before loading anything else!
    instana({
        tracing: {
            enabled: true
        }
    });

    const mongoClient = require('mongodb').MongoClient;
    const mongoObjectID = require('mongodb').ObjectID;
    const redis = require('redis');
    const bodyParser = require('body-parser');
    const express = require('express');
    const pino = require('pino');
    const expPino = require('express-pino-logger');

    // MongoDB
    var db;
    var usersCollection;
    var ordersCollection;
    var mongoConnected = false;

    const logger = pino({
        level: 'info',
        prettyPrint: false,
        useLevelLabels: true
    });
    const expLogger = expPino({
        logger: logger

    });

    const app = express();

    app.use(expLogger);

    app.use((req, res, next) => {
        res.set('Timing-Allow-Origin', '*');
        res.set('Access-Control-Allow-Origin', '*');
        next();
    });

    app.use((req, res, next) => {
        let dcs = [
            "asia-northeast2",
            "asia-south1",
            "europe-west3",
            "us-east1",
            "us-west1"
        ];
        let span = instana.currentSpan();
        span.annotate('custom.sdk.tags.datacenter', dcs[Math.floor(Math.random() * dcs.length)]);

        next();
    });

    app.use(bodyParser.urlencoded({ extended: true }));
    app.use(bodyParser.json());

    app.get('/health', (req, res) => {
        var stat = {
            app: 'OK',
            mongo: mongoConnected
        };
        res.json(stat);
    });

    // use REDIS INCR to track anonymous users
    app.get('/uniqueid', (req, res) => {
        // get number from Redis
        redisClient.incr('anonymous-counter', (err, r) => {
            if(!err) {
                res.json({
                    uuid: 'anonymous-' + r
                });
            } else {
                req.log.error('ERROR', err);
                res.status(500).send(err);
            }
        });
    });

    // check user exists
    app.get('/check/:id', (req, res) => {
        if(mongoConnected) {
            usersCollection.findOne({name: req.params.id}).then((user) => {
                if(user) {
                    res.send('OK');
                } else {
                    res.status(404).send('user not found');
                }
            }).catch((e) => {
                req.log.error(e);
                res.send(500).send(e);
            });
        } else {
            req.log.error('database not available');
            res.status(500).send('database not available');
        }
    });

    // return all users for debugging only
    app.get('/users', (req, res) => {
        if(mongoConnected) {
            usersCollection.find().toArray().then((users) => {
                res.json(users);
            }).catch((e) => {
                req.log.error('ERROR', e);
                res.status(500).send(e);
            });
        } else {
            req.log.error('database not available');
            res.status(500).send('database not available');
        }
    });

    app.post('/login', (req, res) => {
        req.log.info('login', req.body);
        if(req.body.name === undefined || req.body.password === undefined) {
            req.log.warn('credentails not complete');
            res.status(400).send('name or passowrd not supplied');
        } else {
            user = {"password": ""};
            if(req.body.name == "alice") {
                user["name"] = "alice";
                user["email"] = "alice@customer.com";
                token_payload = {"sub": user.name, "roles": ["shopper"]};
            } else if (req.body.name == "eve") {
                user["name"] = "eve";
                user["email"] = "eve@customer.com";
                token_payload = {"sub": user.name, "roles": ["shopper"]};
            } else if (req.body.name == "csr-1") {
                user["name"] = "csr-1";
                user["email"] = "csr-1@shop.com";
                token_payload = {"sub": user.name, "roles": ["customer-service"]};
            } else if (req.body.name == "devop-1") {
                user["name"] = "devop-1";
                user["email"] = "devop-1@shop.com";
                token_payload = {"sub": user.name, "roles": ["devop"]};
            }
            user.token = token_payload  // temp store the payload directly
            res.json(user);
        }
                // user.token = jwt.sign(token_payload, "", { expiresIn: '1800s' });
        // if(mongoConnected) {
        //     usersCollection.findOne({
        //         name: req.body.name,
        //     }).then((user) => {
        //         req.log.info('user', user);
        //         if(user) {
        //             if(user.password == req.body.password) {
        //                 // generate jwt
        //                 // FIXME remove private key from source code
        //                 token_payload = {"sub": user.name, "roles": ["shopper"]};
        //                 // user.token = jwt.sign(token_payload, "", { expiresIn: '1800s' });
        //                 user.token = token_payload  // temp store the payload directly
        //                 res.json(user);
        //             } else {
        //                 res.status(404).send('incorrect password');
        //             }
        //         } else {
        //             res.status(404).send('name not found');
        //         }
        //     }).catch((e) => {
        //         req.log.error('ERROR', e);
        //         res.status(500).send(e);
        //     });
        // } else {
        //     req.log.error('database not available');
        //     res.status(500).send('database not available');
        // }
    });

    // TODO - validate email address format
    app.post('/register', (req, res) => {
        req.log.info('register', req.body);
        if(req.body.name === undefined || req.body.password === undefined || req.body.email === undefined) {
            req.log.warn('insufficient data');
            res.status(400).send('insufficient data');
        } else if(mongoConnected) {
            // check if name already exists
            usersCollection.findOne({name: req.body.name}).then((user) => {
                if(user) {
                    req.log.warn('user already exists');
                    res.status(400).send('name already exists');
                } else {
                    // create new user
                    usersCollection.insertOne({
                        name: req.body.name,
                        password: req.body.password,
                        email: req.body.email
                    }).then((r) => {
                        req.log.info('inserted', r.result);
                        res.send('OK');
                    }).catch((e) => {
                        req.log.error('ERROR', e);
                        res.status(500).send(e);
                    });
                }
            }).catch((e) => {
                req.log.error('ERROR', e);
                res.status(500).send(e);
            });
        } else {
            req.log.error('database not available');
            res.status(500).send('database not available');
        }
    });

    app.post('/order/:id', (req, res) => {
        req.log.info('order', req.body);
        // only for registered users
        if(mongoConnected) {
            usersCollection.findOne({
                name: req.params.id
            }).then((user) => {
                if(user) {
                    // found user record
                    // get orders
                    ordersCollection.findOne({
                        name: req.params.id
                    }).then((history) => {
                        if(history) {
                            var list = history.history;
                            list.push(req.body);
                            ordersCollection.updateOne(
                                { name: req.params.id },
                                { $set: { history: list }}
                            ).then((r) => {
                                res.send('OK');
                            }).catch((e) => {
                                req.log.error(e);
                                res.status(500).send(e);
                            });
                        } else {
                            // no history
                            ordersCollection.insertOne({
                                name: req.params.id,
                                history: [ req.body ]
                            }).then((r) => {
                                res.send('OK');
                            }).catch((e) => {
                                req.log.error(e);
                                res.status(500).send(e);
                            });
                        }
                    }).catch((e) => {
                        req.log.error(e);
                        res.status(500).send(e);
                    });
                } else {
                    res.status(404).send('name not found');
                }
            }).catch((e) => {
                req.log.error(e);
                res.status(500).send(e);
            });
        } else {
            req.log.error('database not available');
            res.status(500).send('database not available');
        }
    });

    app.get('/history/:id', (req, res) => {
        if(mongoConnected) {
            ordersCollection.findOne({
                name: req.params.id
            }).then((history) => {
                if(history) {
                    res.json(history);
                } else {
                    res.status(404).send('history not found');
                }
            }).catch((e) => {
                req.log.error(e);
                res.status(500).send(e);
            });
        } else {
            req.log.error('database not available');
            res.status(500).send('database not available');
        }
    });

    // connect to Redis
    var redisClient = redis.createClient({
        host: process.env.REDIS_HOST || 'redis'
    });

    redisClient.on('error', (e) => {
        logger.error('Redis ERROR', e);
    });
    redisClient.on('ready', (r) => {
        logger.info('Redis READY', r);
    });

    // set up Mongo
    function mongoConnect() {
        return new Promise((resolve, reject) => {
            var mongoURL = process.env.MONGO_URL || 'mongodb://mongodb:27017/users';
            mongoClient.connect(mongoURL, (error, client) => {
                if(error) {
                    reject(error);
                } else {
                    db = client.db('users');
                    usersCollection = db.collection('users');
                    ordersCollection = db.collection('orders');
                    resolve('connected');
                }
            });
        });
    }

    function mongoLoop() {
        mongoConnect().then((r) => {
            mongoConnected = true;
            logger.info('MongoDB connected');
        }).catch((e) => {
            logger.error('ERROR', e);
            setTimeout(mongoLoop, 2000);
        });
    }

    mongoLoop();

    // fire it up!
    const port = process.env.USER_SERVER_PORT || '8080';
    app.listen(port, () => {
        logger.info('Started on port', port);
    });
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: user-svc
  labels:
    account: user-svc
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user
  labels:
    service: user
spec:
  replicas: 1
  selector:
    matchLabels:
      service: user
  template:
    metadata:
      labels:
        service: user
    spec:
      volumes:
      - name: opa-config-vol
        configMap:
          name: opa-istio-config
      - name: user-service-code-revision-mount
        configMap:
          name: user-service-code-revision
      serviceAccountName: user-svc
      containers:
      - name: opa
        image: openpolicyagent/opa:latest-envoy
        volumeMounts:
        - readOnly: true
          mountPath: /config
          name: opa-config-vol
        args:
        - "run"
        - "--server"
        - "--ignore=.*"
        - "--config-file=/config/conf.yaml"
        - "--authorization=basic"
        - "--addr=http://127.0.0.1:8181"
        - "--diagnostic-addr=0.0.0.0:8282"
      - name: user
        image: {{ .Values.image.repo }}/rs-user:{{ .Values.image.version }}
        imagePullPolicy: {{ .Values.image.pullPolicy }}
        env:
          # agent networking access
          - name: INSTANA_AGENT_HOST
            valueFrom:
              fieldRef:
                fieldPath: status.hostIP
        ports:
        - containerPort: 8080
        resources:
          limits:
            cpu: 200m
            memory: 100Mi
          requests:
            cpu: 100m
            memory: 50Mi
        volumeMounts:
        - readOnly: true
          mountPath: /tmp/server.js
          name: user-service-code-revision-mount
          subPath: server.js
        # fixme remove these dev-time only temporary things
        command: ["/bin/sh", "-c"]
        args:
          - echo starting;
            npm install nodemon --global;
            npm install jsonwebtoken;
            cp /tmp/server.js /opt/server/server.js;
            nodemon server.js;
            apt update;
            apt -y install vim;
      restartPolicy: Always
